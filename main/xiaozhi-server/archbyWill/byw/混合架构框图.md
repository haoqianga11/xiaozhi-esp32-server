# xiaozhi-server 混合架构框图

## 概述

xiaozhi-server 结合 `asyncio` 事件循环与多类后台线程（含 per-connection `ThreadPoolExecutor`）实现混合并发模型。事件循环负责所有网络 I/O 与状态管理；阻塞或 CPU/IO 密集任务被投递到专用线程中处理，再通过 `asyncio.run_coroutine_threadsafe` 把结果回传主循环。这样的设计既能支撑大量 WebSocket 连接，又能隔离 ASR/LLM/TTS 等耗时逻辑。

## 混合并发骨架

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         xiaozhi-server 并发结构概览                          │
└─────────────────────────────────────────────────────────────────────────────┘
                ┌───────────── asyncio 事件循环 (主线程) ─────────────┐
                │ • WebSocket 握手/收发                                │
                │ • HTTP API / 心跳                                    │
                │ • ConnectionHandler.handle_connection                │
                │ • handleAudioMessage / 状态管理                      │
                └───────────────────────────────────────────────────────┘
                                     │
                                     ▼
        ┌─────────────── ConnectionHandler 协程实例 ───────────────┐
        │ • 同步执行 VAD (Silero)：conn.vad.is_vad                 │
        │ • 音频入队：conn.asr_audio_queue                         │
        │ • executor.submit(...) 投递阻塞任务                      │
        │ • 调度 TTS/ASR/报表等后台线程                           │
        └───────────────────────────────────────────────────────────┘
                                     │
                                     ▼
┌───────────────────────────── 连接专属 ThreadPoolExecutor ─────────────┐
│ • max_workers=5（按需拉起）                                          │
│ • 初始化组件：self.executor.submit(self._initialize_components)       │
│ • 聊天对话：conn.executor.submit(conn.chat, text)                     │
│ • 报表入队：self.executor.submit(self._process_report, item)          │
└────────────────────────────────────────────────────────────────────────┘
                                     │
                                     ▼
┌───────────────────────────── 其它后台线程 / 线程池 ──────────────────┐
│ • ASR 优先级线程：asr_text_priority_thread (daemon)                  │
│     ↳ 内部使用临时 ThreadPoolExecutor(max_workers=2) 处理 ASR/声纹     │
│ • TTS 文本/播放线程：tts_priority_thread、audio_play_priority_thread   │
│ • 上报线程：report_thread（按配置启用）                               │
└────────────────────────────────────────────────────────────────────────┘
                                     │
                                     ▼
┌───────────────────────────── asyncio.run_coroutine_threadsafe ─────────┐
│ • 后台线程结果回推到事件循环                                           │
│ • 确保网络 I/O 始终在主线程执行                                       │
└────────────────────────────────────────────────────────────────────────┘
```

## 任务流转示例

### 音频 → ASR → 对话

```
ESP32 音频包
    ▼
asyncio 协程 (handleAudioMessage)
    │  同步 VAD: conn.vad.is_vad(conn, audio)
    ▼
conn.asr_audio_queue.put(audio)
    ▼
asr_text_priority_thread (daemon)
    │  调用 handleAudioMessage(conn, message)
    │  使用 asyncio.run_coroutine_threadsafe(..., conn.loop)
    ▼
ASR / 声纹线程池 (max_workers=2)
    │  run_asr() / run_voiceprint()
    ▼
识别结果
    ▼
asyncio 协程 startToChat()
    │  投递对话: conn.executor.submit(conn.chat, actual_text)
    ▼
ThreadPoolExecutor 中执行 LLM/TTS/工具调用
```

### TTS 回传

```
conn.chat(...) 生成文本
    ▼
TTSProvider.tts_text_queue / tts_audio_queue
    ▼
tts_priority_thread 处理文本 → audio_play_priority_thread 播放
    │  期间通过 asyncio.run_coroutine_threadsafe(sendAudioMessage(...), conn.loop)
    ▼
asyncio 事件循环 → WebSocket → 设备播放
```

## 关键设计要点

1. **单事件循环负责 I/O**：WebSocket、HTTP、状态心跳等全在 `asyncio` 主线程处理。
2. **VAD 在主线程同步执行**：`conn.vad.is_vad` 在 `handleAudioMessage` 中直接运行，避免额外线程切换。
3. **多队列解耦音频流**：`conn.asr_audio_queue`、`tts_text_queue`、`tts_audio_queue` 等串联不同阶段，保证线程安全。
4. **每连接专用线程池**：`ThreadPoolExecutor(max_workers=5)` 用于初始化、对话、工具调用、报表等阻塞任务，避免阻塞事件循环。
5. **跨线程回调机制**：后台线程使用 `asyncio.run_coroutine_threadsafe` 回推协程（如 `core/providers/asr/base.py:41`、`core/providers/tts/base.py:345`），保证 I/O 始终由事件循环统一调度。
6. **按需加载线程**：ASR、TTS、报表线程均延迟创建，减少空闲资源占用。

## 代码实现要点

### ConnectionHandler 初始化+线程池投递

```python
# main/xiaozhi-server/core/connection.py:93,222
self.executor = ThreadPoolExecutor(max_workers=5)
...
self.executor.submit(self._initialize_components)
```

### 音频处理与 VAD

```python
# main/xiaozhi-server/core/handle/receiveAudioHandle.py:13-40
async def handleAudioMessage(conn, audio):
    have_voice = conn.vad.is_vad(conn, audio)
    await no_voice_close_connect(conn, have_voice)
    await conn.asr.receive_audio(conn, audio, have_voice)
```

### ASR 线程回推事件循环

```python
# main/xiaozhi-server/core/providers/asr/base.py:32-45
def asr_text_priority_thread(self, conn):
    while not conn.stop_event.is_set():
        message = conn.asr_audio_queue.get(timeout=1)
        future = asyncio.run_coroutine_threadsafe(
            handleAudioMessage(conn, message),
            conn.loop,
        )
        future.result()
```

### 对话任务投递线程池

```python
# main/xiaozhi-server/core/handle/receiveAudioHandle.py:71-88
async def startToChat(conn, text):
    ...
    conn.executor.submit(conn.chat, actual_text)
```

### TTS 线程回传音频

```python
# main/xiaozhi-server/core/providers/tts/base.py:256-346
self.audio_play_priority_thread = threading.Thread(...)
...
future = asyncio.run_coroutine_threadsafe(
    sendAudioMessage(self.conn, sentence_type, audio_datas, text),
    self.conn.loop,
)
future.result()
```

## 资源与扩展性

- **协程层**：单事件循环可支撑上千连接，内存开销以连接上下文为主（若 4KB/协程，仅约 4MB）。
- **线程池**：每连接最多创建 5 个线程，但实际按需求懒加载，可根据负载调小/调大 `max_workers`。
- **专用线程**：ASR、TTS、报表线程在各连接首次使用时创建；ASR 额外使用短生命周期 `ThreadPoolExecutor(max_workers=2)` 并及时释放。
- **潜在瓶颈**：在高并发场景需关注总线程数与内存栈空间（默认约 8MB/线程），可考虑共享线程池、调整栈大小或外部服务化。

## 总结

当前实现通过“事件循环 + 背景线程”协调多阶段工作：VAD 与网络 I/O 保持在主线程；阻塞逻辑通过 `ThreadPoolExecutor` 与专用线程异步执行，并依靠 `asyncio.run_coroutine_threadsafe` 将结果安全回传。这一混合架构兼顾了高并发连接处理能力与 AI 任务的隔离性，为 xiaozhi-server 在实时语音交互场景下提供了可靠的性能与扩展空间。
